// Vulnerability Index Calculator for Meghdoot
// Combines flood risk, population exposure, and infrastructure sensitivity

import { SYLHET_FLOOD_ZONES, type FloodZone, type PredictionResult } from "./flood-data";

export interface VulnerabilityResult {
  zoneId: string;
  zoneName: string;
  overallIndex: number; // 0-100
  tier: "Low" | "Moderate" | "High" | "Critical";
  floodRiskScore: number;
  populationFactor: number;
  infrastructureSensitivity: number;
  agriculturalExposure: number;
  components: {
    label: string;
    value: number;
    maxValue: number;
    description: string;
  }[];
}

export interface VulnerabilityOverview {
  zones: VulnerabilityResult[];
  averageIndex: number;
  criticalCount: number;
  highCount: number;
  moderateCount: number;
  lowCount: number;
  totalPopulationAtRisk: number;
}

// Infrastructure sensitivity based on elevation and zone characteristics
function getInfrastructureSensitivity(zone: FloodZone): number {
  // Lower elevation = more infrastructure at risk
  const elevationScore = Math.max(0, 1 - zone.elevation_m / 30);
  // High vulnerability zones have worse infrastructure
  const vulnMultiplier = zone.vulnerability === "high" ? 1.0 : zone.vulnerability === "medium" ? 0.7 : 0.4;
  // Larger radius = more area exposed
  const areaFactor = Math.min(1, zone.radius_km / 8);
  return Math.round((elevationScore * 0.5 + vulnMultiplier * 0.3 + areaFactor * 0.2) * 100);
}

// Population factor: normalized against the average
function getPopulationFactor(zone: FloodZone): number {
  const avgPop = SYLHET_FLOOD_ZONES.reduce((s, z) => s + z.population, 0) / SYLHET_FLOOD_ZONES.length;
  return Math.min(100, Math.round((zone.population / avgPop) * 50));
}

// Agricultural exposure based on zone characteristics
function getAgriculturalExposure(zone: FloodZone): number {
  // Lower elevation areas tend to have more agricultural land
  const elevationFactor = Math.max(0, 1 - zone.elevation_m / 25);
  // Haor areas (Sunamganj, Companiganj) have higher agricultural exposure
  const haorZones = ["z2", "z3", "z4"];
  const haorBonus = haorZones.includes(zone.id) ? 0.3 : 0;
  return Math.round(Math.min(100, (elevationFactor * 0.7 + haorBonus) * 100));
}

export function calculateVulnerability(predictions: PredictionResult[]): VulnerabilityOverview {
  const zones = SYLHET_FLOOD_ZONES.map((zone) => {
    const prediction = predictions.find(p => p.zone_id === zone.id);
    const floodRiskScore = prediction?.risk_score ?? 20;
    const populationFactor = getPopulationFactor(zone);
    const infrastructureSensitivity = getInfrastructureSensitivity(zone);
    const agriculturalExposure = getAgriculturalExposure(zone);

    // Weighted combination
    const overallIndex = Math.round(
      floodRiskScore * 0.35 +
      populationFactor * 0.25 +
      infrastructureSensitivity * 0.25 +
      agriculturalExposure * 0.15
    );

    let tier: VulnerabilityResult["tier"] = "Low";
    if (overallIndex >= 75) tier = "Critical";
    else if (overallIndex >= 50) tier = "High";
    else if (overallIndex >= 30) tier = "Moderate";

    return {
      zoneId: zone.id,
      zoneName: zone.name,
      overallIndex,
      tier,
      floodRiskScore,
      populationFactor,
      infrastructureSensitivity,
      agriculturalExposure,
      components: [
        { label: "Flood Risk", value: floodRiskScore, maxValue: 100, description: "Current predicted flood risk score" },
        { label: "Population Exposure", value: populationFactor, maxValue: 100, description: "Population density relative to average" },
        { label: "Infrastructure", value: infrastructureSensitivity, maxValue: 100, description: "Infrastructure vulnerability to flooding" },
        { label: "Agricultural", value: agriculturalExposure, maxValue: 100, description: "Agricultural land exposure to flood damage" },
      ],
    };
  });

  const averageIndex = Math.round(zones.reduce((s, z) => s + z.overallIndex, 0) / zones.length);
  const totalPopulationAtRisk = zones
    .filter(z => z.tier === "Critical" || z.tier === "High")
    .reduce((s, z) => {
      const zone = SYLHET_FLOOD_ZONES.find(fz => fz.id === z.zoneId);
      return s + (zone?.population ?? 0);
    }, 0);

  return {
    zones: zones.sort((a, b) => b.overallIndex - a.overallIndex),
    averageIndex,
    criticalCount: zones.filter(z => z.tier === "Critical").length,
    highCount: zones.filter(z => z.tier === "High").length,
    moderateCount: zones.filter(z => z.tier === "Moderate").length,
    lowCount: zones.filter(z => z.tier === "Low").length,
    totalPopulationAtRisk,
  };
}
